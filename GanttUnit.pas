{ ****************************************************************** }
{                                                                    }
{   VCL component TGanttChart                                        }
{                                                                    }
{   Gantt Charting Component For Delphi                              }
{                                                                    }
{   Code generated by Component Create for Delphi                    }
{                                                                    }
{   Generated from untitled component definition                     }
{   on 28 March 2007 at 12:55                                        }
{                                                                    }
{   Copyright © 2007 by Dancemammal.com                              }
{                                                                    }
{ ****************************************************************** }

unit GanttUnit;

interface

uses WinTypes, WinProcs, Messages, SysUtils, Classes, Controls,
   Forms, Graphics, DateUtils, Printers, Dialogs, ExtCtrls, Contnrs, GanttDataBinder3;




Const
   GanttVersion = '1.0.0.1';



type
  TOnSelectItemEvent = procedure(ProjectID, ItemID : Integer) of object;
  TOnSelectProjectEvent = procedure(ProjectID : Integer) of object;
  



type
   TPrintTitle = class(TPersistent)
   private
      fAlignment: TAlignment;
      fCaption: string;
      fFont: TFont;
      fOnChange: TNotifyEvent;
      procedure SetAlignment(Val: TAlignment);
      procedure SetCaption(Val: string);
      procedure SetFont(Val: TFont);
   public
      constructor Create(UpdateEvent: TNotifyEvent);
      destructor Destroy; override;
      procedure UpdateControl;
   published
      property Alignment: TAlignment read fAlignment write SetAlignment default taLeftJustify;
      property Caption: string read fCaption write SetCaption;
      property Font: TFont read fFont write SetFont;
      property OnChange: TNotifyEvent read fOnChange write fOnChange;
   end;


   TPrintOptions = class(TPersistent)
   private
      fPrinterOrientation: TPrinterOrientation;
      fPrintReductionSize: Integer;
      fPrinterLeftMargin, fPrinterRightMargin: Integer;
      fPrinterBottomMargin, fPrinterTopMargin: Integer;
      fPrintHeader: TPrintTitle;
      fPrintFooter: TPrintTitle;
      fPreserveAspect: Boolean;
   public
      constructor Create(UpdateEvent: TNotifyEvent);
      destructor Destroy; override;
   published
      property LeftMargin: Integer read fPrinterLeftMargin write fPrinterLeftMargin default 0;
      property TopMargin: Integer read fPrinterTopMargin write fPrinterTopMargin default 0;
      property RightMargin: Integer read fPrinterRightMargin write fPrinterRightMargin default 0;
      property BottomMargin: Integer read fPrinterBottomMargin write fPrinterBottomMargin default 0;
      property Orientation: TPrinterOrientation read fPrinterOrientation write fPrinterOrientation default poLandscape;
      property ReductionSize: integer read fPrintReductionSize write fPrintReductionSize default 100;
      property PrintHeader: TPrintTitle read fPrintHeader write fPrintHeader;
      property PrintFooter: TPrintTitle read fPrintFooter write fPrintFooter;
      property PreserveAspect: Boolean read fPreserveAspect write fPreserveAspect default True;
   end;







type
   TGanttItemStatus = (gsNoActivity, gsWorkInProgress, gsBenchmark, gsHeldForResource, gsCancelled, gsDeferred);
   TGanttItemDrawStyle = (dsBlock, dsArrow, dsBall, dsRing, dsFinish, dsBenchMark, dsEnd, dsDiaGroup, dsPointGroup,
   dsShardGroup);



Type
  TGanttItemLink = Packed Record
          ProjectID : Integer;
          ItemID : Integer;
          HardLink : Boolean;
        end;



type
   TGanttItem = class(TObject)
   private
      FItemBrush: TBrush;
      FItemColour: TColor;
      FItemFont: TFont;
      FItemPen: TPen;
      FStartDate: TDateTime;
      FNumberOfDays: Integer;
      FItemDrawRect: Trect;
      FItemName: string;
      FitemType: TGanttItemDrawStyle;
      FItemLink : TGanttItemLink;
      FItemPosition : TPoint;
      FItemStatus : TGanttItemStatus;
      FItemPercentage : Integer;
      procedure AutoInitialize;
      procedure AutoDestroy;
      function GetItemBrush: TBrush;
      procedure SetItemBrush(Value: TBrush);
      function GetItemColour: TColor;
      procedure SetItemColour(Value: TColor);
      function GetItemFont: TFont;
      procedure SetItemFont(Value: TFont);
      function GetItemPen: TPen;
      procedure SetItemPen(Value: TPen);
      function GetItemLinkType: Boolean;
      procedure SetItemLinkType(Value: Boolean);
      function GetItemStatus: TGanttItemStatus;
      procedure SetItemStatus(Value: TGanttItemStatus);
   protected
      procedure Loaded;
   public
      constructor Create(AOwner: TComponent);
      destructor Destroy;
      Procedure ClearItemLink;
   published
      property ItemBrush: TBrush read GetItemBrush write SetItemBrush;
      property ItemColour: TColor read GetItemColour write SetItemColour;
      property ItemFont: TFont read GetItemFont write SetItemFont;
      property ItemPen: TPen read GetItemPen write SetItemPen;
      property StartDate: TDateTime read FStartDate write FStartdate;
      property Days: Integer read FNumberOfDays write FNumberOfDays;
      property ItemSize: TRect read FItemDrawRect write FItemDrawRect;
      property ItemName: string read FItemName write FItemName;
      property ItemType: TGanttItemDrawStyle read FitemType write FitemType;
      property ItemPosition : TPoint Read FItemPosition write FItemPosition;
      property ItemHardLink : Boolean Read GetItemLinkType write SetItemLinkType;
      property PercentCompleted: Integer read FItemPercentage write FItemPercentage;
      property ItemStatus: TGanttItemStatus read GetItemStatus write SetItemStatus;
   end;

   PGanttItem = ^TGanttItem;


type
   TGanttProject = class(TObjectlist)
   private
      FProjectName: string;
      FProjectResource1: string;
      FProjectResource2: string;
      FItemDrawRect: Trect;
      procedure AutoInitialize;
      procedure AutoDestroy;
      function GetProjectName: string;
      procedure SetProjectName(Value: string);
      function GetProjectResource1: string;
      procedure SetProjectResource1(Value: string);
      function GetProjectResource2: string;
      procedure SetProjectResource2(Value: string);

   protected
      procedure Loaded;
   public
      constructor Create(AOwner: TComponent);
      destructor Destroy; override;
      function AddGanttItem(Item: TGanttItem): Integer;
      function GetGanttItem(Index: Integer): TGanttItem;
      procedure DeleteGanttItem(Index: Integer);
      procedure ClearItems;
   published
      property ProjectName: string read GetProjectName write SetProjectName;
      property ProjectResource1: string
         read GetProjectResource1 write SetProjectResource1;
      property ProjectResource2: string
         read GetProjectResource2 write SetProjectResource2;
      property ItemSize: TRect read FItemDrawRect write FItemDrawRect;
   end;




type
   TGanttChart = class(TCustomControl)
   private
      FMemBitmap : TBitmap;
      FHintTimer : TTimer;
      FInHint : Boolean;
      FOffScreenCanvas : TCanvas;
      FFlatTypeCells: Boolean;
      FPrintOptions: TPrintOptions;
      FGanttProjectList: TObjectlist;
      FMonthCount: Integer;
      FStartMonth: Integer;
      FGanttTitle: string;
      {Paint Consts}
      FBoxWidth: Integer;
      FBoxHeight: Integer;
      FProjectHeight: Integer;
      FDaysWidth: Integer;
      FDaysOnScreen: Integer;
      FDragging : Boolean;
      FLinking : Boolean;
      FResizing : Boolean;
      FShadows : Boolean;
      FShadowSize : Integer;
      FShadowColor : TColor;
      FShowItemLength : Boolean;
      ProjectDragIndex, ItemDragIndex: Integer;
      CurrentProjectIndex, CurrentItemIndex: Integer;
      TempGanttItem: TGanttItem;
      DragGanttItemRect: TRect;
      FProjectTitleColour: TColor;
      FXMLRoot_ElementType: IXMLRoot_ElementType;

      FOnSelectItemEvent : TOnSelectItemEvent;
      FOnSelectProjectEvent : TOnSelectProjectEvent;

      function  GetProjectTitleColour: TColor;
      procedure SetProjectTitleColour(Value: TColor);
      function  GetShadowColour: TColor;
      procedure SetShadowColour(Value: TColor);
      procedure WMLButtonDblClk(var Message: TWMLButtonDblClk); message wm_LButtonDblClk;
      procedure WMLButtonDown(var Message: TWMLButtonDown); message wm_LButtonDown;
      procedure WMLButtonUp(var Message: TWMLButtonUp); message wm_LButtonUp;
      procedure WMRButtonDown(var Message: TWMRButtonDown); message wm_RButtonDown;
      procedure WMMouseMove(var Message: TWMMouseMove); message wm_MouseMove;
      procedure WMSize(var Message: TWMSize); message wm_Size;
      procedure WMEraseBkgnd(var Message: TWMEraseBkgnd); message WM_ERASEBKGND;

      { Private methods of TGanttChart }
        { Method to set variable and property values and create objects }
      procedure AutoInitialize;
        { Method to free any objects created by AutoInitialize }
      procedure AutoDestroy;
        { Read method for property FlatTypeCells }
      function GetFlatTypeCells: Boolean;
        { Write method for property FlatTypeCells }
      procedure SetFlatTypeCells(Value: Boolean);
        { Read method for property PrintOptions }
      function GetPrintOptions: TPrintOptions;
        { Write method for property PrintOptions }
      procedure SetPrintOptions(Value: TPrintOptions);

      function GetGanttProjects: TObjectlist;
        { Write method for property PrintOptions }
      procedure SetGanttProjects(Value: TObjectlist);
      procedure ReLoadObjectList;
      Procedure CreateOffscreenBitMap;
      Procedure DestroyOffscreenBitMap;
   protected
      { Protected fields of TGanttChart }
      PrinterPageHeight, PrinterPageWidth: Integer;
      PrinterLeftMargin, PrinterTopMargin: Integer;
      PrinterRightMargin, PrinterBottomMargin: Integer;
      OldX, OldY: Integer;
      CurrentX, CurrentY: Integer;
      DeltaX, DeltaY: Integer; // for drag drop etc
      { Protected methods of TGanttChart }
      procedure Click; override;
      procedure KeyPress(var Key: Char); override;
      procedure Loaded; override;
      procedure OnHintTimer(Sender: TObject);
      Function CalculateShadowoffsett(StartRect : TRect): TRect;
      procedure PaintHint;
      procedure PaintHeader;
      procedure PaintProjects;
      procedure PaintOneProject(StartY: Integer; Project: TGanttProject);
      procedure PaintOneGanttItem(StartY: Integer; GanttItem: TGanttItem);
      procedure PaintOneMovingGanttItem(StartY: Integer; GanttItem: TGanttItem);
      procedure paintArrowStyle(ItemRect: TRect; UseCanvas : TCanvas);
      procedure PaintDiamondStyle(ItemRect: TRect; UseCanvas : TCanvas);
      procedure PaintPointStyle(ItemRect: TRect; UseCanvas : TCanvas);
      procedure PaintShardStyle(ItemRect: TRect; UseCanvas : TCanvas);
      procedure PaintItemLinks;
      procedure Paint; override;
      function CreateXMLFile: string;
      function LoadChart(XMLFileName: string): Boolean;
      Procedure ResetDraggedLinks(NewProjectID, NewItemID, DaysMoved : Integer);
      Procedure ResetHardLink(ProjectID, ItemID, DaysMoved : Integer);
      function GetDayWidth(ClientWidth, Days: Integer): Integer;
   public
      { Public fields and properties of TGanttChart }

      { Public methods of TGanttChart }
      procedure ClearCells;
      constructor Create(AOwner: TComponent); override;
      destructor Destroy; override;
      function GetEndDate: TDateTime;
      function GetStartDate: TDateTime;
      procedure PrintChart;
      Procedure SaveChartToBitmap(FileName : String);
      function XYtoGanttItem(X, Y: Integer; var ProjectID, ItemID: Integer): Boolean;
      function XYtoGanttProject(X, Y: Integer; var ProjectID: Integer): Boolean;
      function XYtoGanttProjectTitle(X, Y: Integer; var ProjectID: Integer): Boolean;
      {projects stuff}
      function GetProject(Index: Integer): TGanttProject;
      function AddNewProject(Item: TGanttProject): Integer;
      procedure DeleteProject(Index: Integer);
      procedure ClearProjects;
      
      Procedure DeleteProjectItem(ProjectIndex, ItemIndex : Integer);
      function GetProjectItem(ProjectIndex, ItemIndex : Integer): TGanttItem;

      Procedure SavetoXML(Filename : String);
      Procedure LoadFromXML(Filename : String);


   published
      { Published properties of TGanttChart }
      property Align;
      property OnClick;
      property OnDblClick;
      property OnDragDrop;
      property OnEnter;
      property OnExit;
      property OnKeyDown;
      property OnKeyPress;
      property OnKeyUp;
      property OnMouseDown;
      property OnMouseMove;
      property OnMouseUp;
      property OnSelectItem :TOnSelectItemEvent read FOnSelectItemEvent write FOnSelectItemEvent;
      property OnSelectProject :TOnSelectProjectEvent read FOnSelectProjectEvent write FOnSelectProjectEvent;

      property FlatTypeCells: Boolean read GetFlatTypeCells write SetFlatTypeCells default True;
      property PrintOptions: TPrintOptions read GetPrintOptions write SetPrintOptions;
      property NumberofMonths: Integer read FMonthCount write FMonthCount;
      property StartMonth: Integer read FStartMonth write FStartMonth;
      property GanttTitle: string read FGanttTitle write FGanttTitle;
      property GanttProjects: TObjectlist read FGanttProjectList write FGanttProjectList;
      property ProjectTitleColour: TColor read GetProjectTitleColour write SetProjectTitleColour;
      property ShadowColour: TColor read GetShadowColour write SetShadowColour;
      property StartLinking : Boolean read FLinking write FLinking;
      property ProjectHeight : Integer read FProjectHeight write FProjectHeight;
      property DayWidth : Integer read FDaysWidth write FDaysWidth;
      property ShowItemLength : Boolean read FShowItemLength write FShowItemLength;
      property Shadows : Boolean Read FShadows write FShadows;
      property ShadowSize : Integer read FShadowSize write FShadowSize;
   end;

procedure Register;

implementation


Uses GBlur2, MiscHelpFunctions;


procedure Register;
begin
     { Register TGanttChart with Samples as its
       default page on the Delphi component palette }
   RegisterComponents('Samples', [TGanttChart]);
end;




{+++++++++++++++++++++ gantt Items ++++++++++++++++++++++++}


procedure TGanttItem.AutoInitialize;
begin
   FItemBrush := TBrush.Create;
   FItemFont := TFont.Create;
   FItemPen := TPen.Create;
   FStartDate := Now;
   FNumberOfDays := 30;
   FitemType := dsBlock;
   FItemFont.Name := 'Tahoma';
   FItemFont.Size := 7;
   FItemStatus := gsWorkInProgress;
   ClearItemLink;
end;


procedure TGanttItem.AutoDestroy;
begin
   FItemBrush.Free;
   FItemFont.Free;
   FItemPen.Free;
end;


function TGanttItem.GetItemBrush: TBrush;
begin
   Result := FItemBrush;
end;


procedure TGanttItem.SetItemBrush(Value: TBrush);
begin
   FItemBrush.Assign(Value);
end;


function TGanttItem.GetItemColour: TColor;
begin
   Result := FItemColour;
end;


procedure TGanttItem.SetItemColour(Value: TColor);
begin
   FItemColour := Value;
end;


function TGanttItem.GetItemFont: TFont;
begin
   Result := FItemFont;
end;


procedure TGanttItem.SetItemFont(Value: TFont);
begin
   FItemFont.Assign(Value);
end;


function TGanttItem.GetItemStatus: TGanttItemStatus;
begin
   Result := FItemStatus;
end;


procedure TGanttItem.SetItemStatus(Value: TGanttItemStatus);
begin
   FItemStatus := Value;
end;




function TGanttItem.GetItemPen: TPen;
begin
   Result := FItemPen;
end;


procedure TGanttItem.SetItemPen(Value: TPen);
begin
   FItemPen.Assign(Value);
end;


function TGanttItem.GetItemLinkType: Boolean;
begin
   Result := FItemLink.HardLink;
end;


procedure TGanttItem.SetItemLinkType(Value: Boolean);
begin
   FItemLink.HardLink := Value;
end;


constructor TGanttItem.Create(AOwner: TComponent);
begin
   inherited Create;
   AutoInitialize;
end;

destructor TGanttItem.Destroy;
begin
   AutoDestroy;
   inherited Destroy;
end;

procedure TGanttItem.Loaded;
begin
{}
end;

procedure TGanttItem.ClearItemLink;
begin
    FItemLink.ProjectID := -1;
    FItemLink.ItemID := -1;
    FItemLink.HardLink := False;
end;



{ +++++++++++++++++++++++++++ Gantt Projects +++++++++++++++++++++++++}



procedure TGanttProject.ClearItems;
var
   Item: TGanttItem;
   Index: Integer;
begin
   for Index := Self.Count - 1 downto 0 do
   begin
     //  Item := GetGanttItem(Index);
    //   Item.Free;
      Self.Delete(Index);
   end;
end;




{ Method to set variable and property values and create objects }

procedure TGanttProject.AutoInitialize;
begin
end; { of AutoInitialize }

{ Method to free any objects created by AutoInitialize }

procedure TGanttProject.AutoDestroy;
begin
   ClearItems;
end; { of AutoDestroy }

{ Read method for property ProjectName }

function TGanttProject.GetProjectName: string;
begin
   Result := FProjectName;
end;

{ Write method for property ProjectName }

procedure TGanttProject.SetProjectName(Value: string);
begin
   FProjectName := Value;
end;

{ Read method for property ProjectResource1 }

function TGanttProject.GetProjectResource1: string;
begin
   Result := FProjectResource1;
end;

{ Write method for property ProjectResource1 }

procedure TGanttProject.SetProjectResource1(Value: string);
begin
   FProjectResource1 := Value;
end;

{ Read method for property ProjectResource2 }

function TGanttProject.GetProjectResource2: string;
begin
   Result := FProjectResource2;
end;

{ Write method for property ProjectResource2 }

procedure TGanttProject.SetProjectResource2(Value: string);
begin
   FProjectResource2 := Value;
end;

constructor TGanttProject.Create(AOwner: TComponent);
begin
     { Call the Create method of the parent class }
   inherited Create;

     { AutoInitialize sets the initial values of variables and      }
     { properties; also, it creates objects for properties of       }
     { standard Delphi object types (e.g., TFont, TTimer,           }
     { TPicture) and for any variables marked as objects.           }
     { AutoInitialize method is generated by Component Create.      }
   AutoInitialize;

     { Code to perform other tasks when the component is created }

end;

destructor TGanttProject.Destroy;
begin
     { AutoDestroy, which is generated by Component Create, frees any   }
     { objects created by AutoInitialize.                               }
   AutoDestroy;

     { Here, free any other dynamic objects that the component methods  }
     { created but have not yet freed.  Also perform any other clean-up }
     { operations needed before the component is destroyed.             }

     { Last, free the component by calling the Destroy method of the    }
     { parent class.                                                    }
   inherited Destroy;
end;

procedure TGanttProject.Loaded;
begin
     { Perform any component setup that depends on the property
       values having been set }  
end;



function TGanttProject.AddGanttItem(Item: TGanttItem): Integer;
begin
   Self.Add(Item);
end;

function TGanttProject.GetGanttItem(Index: Integer): TGanttItem;
begin
   if Index < Self.Count then
      Result := TGanttItem(Self.Items[index]);
end;


procedure TGanttProject.DeleteGanttItem(Index: Integer);
var
   Item: TGanttItem;

begin
   if Index < Self.Count then
   begin
      Item := GetGanttItem(Index);
      Item.Free;
      Self.Delete(Index);
   end;
end;






{++++++++++++++++ print options +++++++++++++++++++++++++}

constructor TPrintOptions.Create(UpdateEvent: TNotifyEvent);
begin
   inherited Create;
   fPreserveAspect := True;
   fPrinterOrientation := poLandscape;
   fPrintReductionSize := 100;
   fPrinterLeftMargin := 0;
   fPrinterTopMargin := 0;
   fPrinterRightMargin := 0;
   fPrinterBottomMargin := 0;
   fPrintHeader := TPrintTitle.Create(nil);
   fPrintFooter := TPrintTitle.Create(nil);
end;


destructor TPrintOptions.Destroy;
begin
   fPrintFooter.Free;
   fPrintHeader.Free;
   inherited Destroy;
end;




{++++++++++++++++++ print title +++++++++++++++++++++++}

procedure TPrintTitle.SetAlignment(Val: TAlignment);
begin
   if fAlignment <> Val then
   begin
      fAlignment := Val;
      UpdateControl;
   end;
end;


procedure TPrintTitle.SetCaption(Val: string);
begin
   if fCaption <> Val then
   begin
      fCaption := Val;
      UpdateControl;
   end;
end;


procedure TPrintTitle.SetFont(Val: TFont);
begin
   if fFont <> Val then
   begin
      fFont.Assign(Val);
      UpdateControl;
   end;
end;


constructor TPrintTitle.Create(UpdateEvent: TNotifyEvent);
begin
   inherited Create;
   fFont := TFont.Create;
   fCaption := '';
   fAlignment := taLeftJustify;
end;


destructor TPrintTitle.Destroy;
begin
   fFont.Free;
   inherited Destroy;
end;


procedure TPrintTitle.UpdateControl;
begin
   if Assigned(fOnChange) then fOnChange(Self);
end;



{++++++++++++++++++++++++++ Gantt Chart +++++++++++++++++++++++++++++}


procedure TGanttChart.WMEraseBkgnd(var Message: TWMEraseBkgnd);
begin
   Invalidate;
   Message.Result := 1;
end;

procedure TGanttChart.WMLButtonDblClk(var Message: TWMLButtonDblClk);
begin
  { If a selection has been made, and a double click procedure has been set,
    execute it }
{  if (hSelecting = ypSelected) and (Assigned(fOnYearDblClick)) then
    fOnYearDblClick(StDay,EnDay,EnMonth,StMonth,fStartDate,fEndDate);}
end;


procedure TGanttChart.WMLButtonDown(var Message: TWMLButtonDown);
var
   Temp: TPoint;
   TempID : Integer;
begin
   inherited;
  // Check to see if the mouse is over a cell
   Temp := ClientToScreen(Point(Message.XPos, Message.YPos));
   if not (FindDragTarget(Temp, True) = Self) then Exit;
   if XYtoGanttItem(Message.XPos, Message.YPos, ProjectDragIndex, ItemDragIndex) = True then
   begin
      if ((Message.XPos > DragGanttItemRect.Right - 3) and (Message.XPos < DragGanttItemRect.Right + 3)) then
        FResizing := True
         else
          if FLinking = False then FDragging := True;
      OldX := Message.XPos;
      OldY := Message.YPos;
   end;
//   Invalidate;
end;



Procedure TGanttChart.ResetDraggedLinks(NewProjectID, NewItemID, DaysMoved : Integer);
var
   Project: TGanttProject;
   GanttItem: TGanttItem;
   ProIndex, ItmIndex : Integer;
begin
   for ProIndex := 0 to FGanttProjectList.count - 1 do
   begin
      Project := GetProject(ProIndex);
      for ItmIndex := 0 to Project.Count - 1 do
      begin
         GanttItem := Project.GetGanttItem(ItmIndex);
         if (GanttItem.FItemLink.ProjectID = ProjectDragIndex) and (GanttItem.FItemLink.ItemID = ItemDragIndex) then
         begin
            GanttItem.FItemLink.ProjectID := NewProjectID;
            GanttItem.FItemLink.ItemID := NewItemID;
            if GanttItem.FItemLink.HardLink = True then
               GanttItem.FStartDate := incday(GanttItem.FStartDate, DaysMoved);
         end;
      end;
   end;
end;



Procedure TGanttChart.ResetHardLink(ProjectID, ItemID, DaysMoved : Integer);
var
   Project: TGanttProject;
   GanttItem: TGanttItem;
begin
      Project := GetProject(ProjectID);
      GanttItem := Project.GetGanttItem(ItemID);
      GanttItem.FStartDate := incday(GanttItem.FStartDate, DaysMoved);
end;




procedure TGanttChart.WMLButtonUp(var Message: TWMLButtonUp);
var
   Temp: TPoint;
   ProjectDragToIndex, ItemDragToIndex: Integer;
   Project1, Project2: TGanttProject;
   GanttItem: TGanttItem;
   DaysMoved: Integer;

begin
   if FDragging then
    begin
     if XYtoGanttProject(Message.XPos, Message.YPos, ProjectDragToIndex) = True then
      begin
         Temp := Point(Message.XPos, Message.YPos);
         // work out if we have moved along the chart
         if Temp.X < OldX then
         begin
            DaysMoved := Trunc((OldX - Temp.X) / FDaysWidth);
            DaysMoved := -DaysMoved;
         end
         else
         begin
            DaysMoved := Trunc((Temp.X - OldX) / FDaysWidth);
         end;

         Project1 := GetProject(ProjectDragIndex);
         Project2 := GetProject(ProjectDragToIndex);
         GanttItem := Project1.GetGanttItem(ItemDragIndex);
         GanttItem.FStartDate := incday(GanttItem.FStartDate, DaysMoved);
         ItemDragToIndex := Project2.Add(Project1.Extract(GanttItem));
         Project1.Pack;
         if (GanttItem.ItemHardLink = true) then
            ResetHardLink(GanttItem.FItemLink.ProjectID,GanttItem.FItemLink.ItemID,DaysMoved);

         ResetDraggedLinks(ProjectDragToIndex,ItemDragToIndex,DaysMoved); {do links}
         Cursor := crArrow;
         FDragging := False;
      end;
 end;


   if FLinking then // create a link to another Item
   begin
   if XYtoGanttItem(Message.XPos, Message.YPos, ProjectDragToIndex, ItemDragToIndex) = True then
   begin
         Project1 := GetProject(ProjectDragIndex);
         GanttItem := Project1.GetGanttItem(ItemDragIndex);
         GanttItem.FItemLink.ProjectID := ProjectDragToIndex;
         GanttItem.FItemLink.ItemID := ItemDragToIndex;
         GanttItem.FItemLink.HardLink := False;
         Cursor := crArrow;
         FLinking := False;
   end;
   end;

   if FResizing then
   begin
      if XYtoGanttProject(Message.XPos, Message.YPos, ProjectDragToIndex) = True then
   begin
         Temp := Point(Message.XPos, Message.YPos);
         // work out if we have moved along the chart
         if Temp.X < OldX then
         begin
            DaysMoved := Trunc((OldX - Temp.X) / FDaysWidth);
            DaysMoved := -DaysMoved;
         end
         else
         begin
            DaysMoved := Trunc((Temp.X - OldX) / FDaysWidth);
         end;

         Project1 := GetProject(ProjectDragIndex);
         GanttItem := Project1.GetGanttItem(ItemDragIndex);
         GanttItem.FNumberOfDays := GanttItem.FNumberOfDays + DaysMoved;
         Cursor := crArrow;
         FResizing := False;
   end;
  end;


  if XYtoGanttItem(Message.XPos, Message.YPos, ProjectDragToIndex, ItemDragToIndex) = True then
     If Assigned(FOnSelectItemEvent) then
              FOnSelectItemEvent(ProjectDragToIndex,ItemDragToIndex);

   if XYtoGanttProjectTitle(Message.XPos, Message.YPos, ProjectDragToIndex) = True then
   begin
      ProjectDragIndex := ProjectDragToIndex;
      if Assigned(FOnSelectItemEvent) then
          FOnSelectProjectEvent(ProjectDragIndex);
   end;
   DeltaX := 0;
   DeltaY := 0;
   Invalidate;
   inherited;
end;




procedure TGanttChart.WMMouseMove(var Message: TWMMouseMove);
var
   Temp: TPoint;
   ShowRect: TRect;
   TempProj, TempItem : Integer;
   CursorType : Integer;
begin
   inherited;
   if FInHint = True then Invalidate;
   FInHint := False;
   FHintTimer.Enabled := False;
   Temp := Point(Message.XPos, Message.YPos);
   CurrentX := Message.XPos;
   CurrentY := Message.YPos;
   CursorType := 1; //arrow

   if XYtoGanttItem(Message.XPos, Message.YPos, TempProj, TempItem) = True then
   begin
      FHintTimer.Enabled := True;
      if ((Message.XPos > DragGanttItemRect.Right - 3) and (Message.XPos < DragGanttItemRect.Right + 3)) then
        CursorType := 2 // streching
         else
          if FLinking = False then CursorType := 3 // dragging
          else
             if FLinking = True then CursorType := 4; // linking
   end;
   
   case CursorType of
         1 : Cursor := crArrow;
         2 : Cursor := crSizeWE;
         3 : Cursor := crDrag;
         4 : Cursor := crHandPoint;
    end;
    
   if FDragging then
   begin
      DeltaX := Temp.X - Oldx;
      DeltaY := Temp.Y - Oldy;
      ShowRect.Top := DragGanttItemRect.Top + DeltaY;
      ShowRect.Bottom := DragGanttItemRect.Bottom + DeltaY;
      showRect.Left := DragGanttItemRect.Left + DeltaX;
      showRect.Right := DragGanttItemRect.Right + DeltaX;
     invalidate;
   end;
   if FResizing then
   begin
      DeltaX := Temp.X - Oldx;
      if (Temp.X <= DragGanttItemRect.Left + FDaysWidth)then DeltaX := FDaysWidth;
      ShowRect.Top := DragGanttItemRect.Top;
      ShowRect.Bottom := DragGanttItemRect.Bottom;
      showRect.Left := DragGanttItemRect.Left;
      showRect.Right := DragGanttItemRect.Right + DeltaX;
     invalidate;
   end;

end;



procedure TGanttChart.WMRButtonDown(var Message: TWMRButtonDown);
begin
   inherited;
  { If a selection has been made, and a right click procedure has been set,
    execute it }
end;



procedure TGanttChart.WMSize(var Message: TWMSize);
begin
   Invalidate;
end;


{+++++++++++++++++++++++  XML filer Stuff  ++++++++++++++++++++++++++}


function TGanttChart.LoadChart(XMLFileName: string): Boolean;
begin
   FXMLRoot_ElementType := LoadRoot_Element(XMLFileName);
   ReLoadObjectList;
   Invalidate;
end;



function TGanttChart.CreateXMLFile: string;
var
   ProjectIndex, ItemCount: Integer;
   TempProject : TGanttProject;
   TempGanttItem : TGanttItem;
   GanttItem : IXMLProject_ItemType;           //items
   GanttProject: IXMLGantt_ProjectType;       //projects
   MyXMLRoot_ElementType: IXMLRoot_ElementType; //gantt chart

begin
   MyXMLRoot_ElementType := NewRoot_Element;
   MyXMLRoot_ElementType.Gantt_Chart.Gantt_Chart_Details.Gantt_Title := FGanttTitle;
   MyXMLRoot_ElementType.Gantt_Chart.Gantt_Chart_Details.Start_Month := FStartMonth;
   MyXMLRoot_ElementType.Gantt_Chart.Gantt_Chart_Details.Number_of_Months := FMonthCount;
   MyXMLRoot_ElementType.Gantt_Chart.Gantt_Chart_Details.Project_Title_Colour := ColortoString(FProjectTitleColour);
   MyXMLRoot_ElementType.Gantt_Chart.Gantt_Chart_Details.Shadow_Colour := ColortoString(FShadowColor);
   MyXMLRoot_ElementType.Gantt_Chart.Gantt_Chart_Details.Project_Height := FProjectHeight;
   MyXMLRoot_ElementType.Gantt_Chart.Gantt_Chart_Details.Day_Width := FDaysWidth;
   MyXMLRoot_ElementType.Gantt_Chart.Gantt_Chart_Details.Gantt_Version := GanttVersion;
   // projects
   for ProjectIndex := 0 to (FGanttProjectList.Count -1) do
   begin
     TempProject := GetProject(ProjectIndex);
     GanttProject := MyXMLRoot_ElementType.Gantt_Chart.Gantt_Projects.Add;
     GanttProject.Gantt_Project_Name := TempProject.FProjectName;
     GanttProject.Gantt_Project_Resource1 := TempProject.FProjectResource1;
     GanttProject.Gantt_Project_Resource2 := TempProject.FProjectResource2;

   // items
   for ItemCount := 0 to (TempProject.Count - 1) do
   begin
      TempGanttItem := TempProject.GetGanttItem(ItemCount);
      GanttItem := GanttProject.Gantt_Project_Items.Add;
      GanttItem.Item_Name := TempGanttItem.FItemName;
      GanttItem.Item_Type := ItemTypetostring(TempGanttItem.FitemType);
      GanttItem.Item_Status := StatusTypeToString(TempGanttItem.FItemStatus);
      GanttItem.Item_Percent_Completed := TempGanttItem.FItemPercentage;
      GanttItem.Item_Colour := Colortostring(TempGanttItem.FItemColour);
      GanttItem.Item_Start_Date := DatetoStr(TempGanttItem.FStartDate);
      GanttItem.Item_Days := TempGanttItem.FNumberOfDays;
      GanttItem.Item_Brush.Item_Brush_Colour := Colortostring(TempGanttItem.FItemBrush.Color);
      GanttItem.Item_Brush.Item_Brush_Style := BrushStyletoString(TempGanttItem.FItemBrush.Style);
      GanttItem.Item_Pen.Item_Pen_Colour := Colortostring(TempGanttItem.FItemPen.Color);
      GanttItem.Item_Pen.Item_Pen_Size := TempGanttItem.FItemPen.Width;
      GanttItem.Item_Link.Project_ID := TempGanttItem.FItemLink.ProjectID;
      GanttItem.Item_Link.Item_ID := TempGanttItem.FItemLink.ItemID;
   end;
   end;//projects
   Result := MyXMLRoot_ElementType.XML;
end;




procedure TGanttChart.ReLoadObjectList;
var
   ProjectIndex, ItemCount: Integer;
   ProjectNumber, ItemNumber : Integer;
   TempProject : TGanttProject;
   TempGanttItem : TGanttItem;
   GanttItem : IXMLProject_ItemType;           //items
   GanttProject: IXMLGantt_ProjectType;       //projects
begin
   ClearProjects;
   FGanttTitle := FXMLRoot_ElementType.Gantt_Chart.Gantt_Chart_Details.Gantt_Title;
   FStartMonth := FXMLRoot_ElementType.Gantt_Chart.Gantt_Chart_Details.Start_Month;
   FMonthCount := FXMLRoot_ElementType.Gantt_Chart.Gantt_Chart_Details.Number_of_Months;
   FProjectTitleColour := StringtoColor(FXMLRoot_ElementType.Gantt_Chart.Gantt_Chart_Details.Project_Title_Colour);
   FShadowColor := StringtoColor(FXMLRoot_ElementType.Gantt_Chart.Gantt_Chart_Details.Shadow_Colour);
   FProjectHeight := FXMLRoot_ElementType.Gantt_Chart.Gantt_Chart_Details.Project_Height;
   FDaysWidth := FXMLRoot_ElementType.Gantt_Chart.Gantt_Chart_Details.Day_Width;

   ProjectNumber := FXMLRoot_ElementType.Gantt_Chart.Gantt_Projects.Count;
   // projects
   for ProjectIndex := 0 to ProjectNumber - 1 do
   begin
      GanttProject := FXMLRoot_ElementType.Gantt_Chart.Gantt_Projects.Gantt_Project[ProjectIndex];
      TempProject := TGanttProject.Create(nil);
      AddNewProject(TempProject);
      TempProject.FProjectName := GanttProject.Gantt_Project_Name;
      TempProject.FProjectResource1 := GanttProject.Gantt_Project_Resource1;
      TempProject.FProjectResource2 := GanttProject.Gantt_Project_Resource2;

      ItemNumber := GanttProject.Gantt_Project_Items.Count;
      // project items
      for ItemCount := 0 to ItemNumber -1 do
      begin
        GanttItem := GanttProject.Gantt_Project_Items.Project_Item[ItemCount];
        TempGanttItem := TGanttItem.Create(nil);
        TempProject.AddGanttItem(TempGanttItem);
        TempGanttItem.FItemName := GanttItem.Item_Name;
        TempGanttItem.FitemType := StringtoItemType(GanttItem.Item_Type);
        TempGanttItem.FItemStatus := StringToStatusType(GanttItem.Item_Status);
        TempGanttItem.FItemPercentage := GanttItem.Item_Percent_Completed;

        TempGanttItem.FItemColour := StringtoColor(GanttItem.Item_Colour);
        TempGanttItem.FStartDate := StrtoDate(GanttItem.Item_Start_Date);
        TempGanttItem.FNumberOfDays := GanttItem.Item_Days;
        TempGanttItem.FItemBrush.Color := StringtoColor(GanttItem.Item_Brush.Item_Brush_Colour);
        TempGanttItem.FItemBrush.Style := StringtoBrushStyle(GanttItem.Item_Brush.Item_Brush_Style);
        TempGanttItem.FItemPen.Color := StringtoColor(GanttItem.Item_Pen.Item_Pen_Colour);
        TempGanttItem.FItemPen.Width := GanttItem.Item_Pen.Item_Pen_Size;
        TempGanttItem.FItemLink.ProjectID := GanttItem.Item_Link.Project_ID;
        TempGanttItem.FItemLink.ItemID :=  GanttItem.Item_Link.Item_ID;
      end;  // items
   end; // projects
end;


{Public procedures }
Procedure TGanttChart.SavetoXML(Filename : String);
var
  FilerList : TStringlist;
begin
 FilerList := TStringlist.Create;
 try
    FilerList.Text := CreateXMLFile;
    FilerList.SaveToFile(Filename);
  finally
     FilerList.free;
  end;
end;


Procedure TGanttChart.LoadFromXML(Filename : String);
begin
   LoadChart(Filename);
end;

{+++++++++++++++++++++end xml filer stuff+++++++++++++++++++++}


{ Method to set variable and property values and create objects }

Procedure TGanttChart.CreateOffscreenBitMap;
begin
 // FMemBitmap := Gantt_MemBitmap.Create(ClientWidth,ClientHeight);
  FMemBitmap := TBitmap.Create;
  FMemBitmap.PixelFormat := pf24bit;
  FOffScreenCanvas := FMemBitmap.Canvas;
 //FOffScreenCanvas := Canvas;
end;

Procedure TGanttChart.DestroyOffscreenBitMap;
begin
  FMemBitmap.Free;
end;



procedure TGanttChart.AutoInitialize;
begin
   FFlatTypeCells := True;
   FMonthCount := 4;
   FStartMonth := 3;
   FDaysWidth := 12;
   FBoxWidth := 120;
   FBoxHeight := 40;
   FProjectHeight := 16;
   FShowItemLength := True;
   FDragging := False;
   FLinking := False;
   FResizing := False;
   FShadows := True;
   FShadowSize := 3;
   FShadowColor := clTeal;//clSilver;
   CreateOffscreenBitMap;
   FGanttTitle := 'Dancemammal.com Gantt Creator Component';
   FGanttProjectList := TObjectList.Create;
   FGanttProjectList.OwnsObjects := True;
   FPrintOptions := TPrintOptions.Create(nil);
   FHintTimer := TTimer.create(nil);
   FHintTimer.Interval := 2000;
   FHintTimer.Enabled := False;
   FHintTimer.OnTimer := OnHintTimer;
   FInHint := False;
   FProjectTitleColour := clMoneyGreen;
end; { of AutoInitialize }

{ Method to free any objects created by AutoInitialize }

procedure TGanttChart.AutoDestroy;
begin
   ClearProjects;
   FGanttProjectList.Free;
   FPrintOptions.Free;
   FHintTimer.free;
   DestroyOffscreenBitMap;
     { No objects from AutoInitialize to free }
end; { of AutoDestroy }


procedure TGanttChart.ClearProjects;
var
   Project: TGanttProject;
   Index: Integer;
begin
   for Index := FGanttProjectList.Count - 1 downto 0 do
   begin
      FGanttProjectList.Delete(Index);
      FGanttProjectList.Pack;
   end;
   FGanttProjectList.Clear;
   Invalidate;
end;


function TGanttChart.AddNewProject(Item: TGanttProject): Integer;
begin
   FGanttProjectList.Add(Item);
   Invalidate;
end;



function TGanttChart.GetProject(Index: Integer): TGanttProject;
begin
   if Index < FGanttProjectList.Count then
      Result := TGanttProject(FGanttProjectList.Items[index]);
end;


procedure TGanttChart.DeleteProject(Index: Integer);
var
   Item: TGanttProject;

begin
   if Index < FGanttProjectList.Count then
   begin
      Item := GetProject(Index);
      Item.Free;
      FGanttProjectList.Delete(Index);
      Invalidate;
   end;
end;



function TGanttChart.GetProjectItem(ProjectIndex, ItemIndex : Integer): TGanttItem;
var
 TempProject : TGanttProject;
begin
   Result := nil;
   if ProjectIndex < FGanttProjectList.Count then
   begin
      TempProject := TGanttProject(FGanttProjectList.Items[ProjectIndex]);
      if ItemIndex < TempProject.Count then
         Result := TempProject.GetGanttItem(ItemIndex);
   end;
end;


Procedure TGanttChart.DeleteProjectItem(ProjectIndex, ItemIndex : Integer);
var
 TempProject : TGanttProject;
begin
   if ProjectIndex < FGanttProjectList.Count then
   begin
     TempProject := TGanttProject(FGanttProjectList.Items[ProjectIndex]);
      if ItemIndex < TempProject.Count then
         TempProject.Delete(ItemIndex);
   end;
end;





{ Read method for property FlatTypeCells }

function TGanttChart.GetFlatTypeCells: Boolean;
begin
   Result := FFlatTypeCells;
end;

{ Write method for property FlatTypeCells }

procedure TGanttChart.SetFlatTypeCells(Value: Boolean);
begin
   FFlatTypeCells := Value;
end;


function TGanttChart.GetGanttProjects: TObjectlist;
begin
   Result := FGanttProjectList;
end;

procedure TGanttChart.SetGanttProjects(Value: TObjectlist);
begin
   FGanttProjectList := Value;
end;

{ Read method for property PrintOptions }

function TGanttChart.GetPrintOptions: TPrintOptions;
begin
   Result := FPrintOptions;
end;

{ Write method for property PrintOptions }

procedure TGanttChart.SetPrintOptions(Value: TPrintOptions);
begin
   FPrintOptions := Value;

     { If changing this property affects the appearance of
       the component, call Invalidate here so the image will be
       updated. }
     { Invalidate; }
end;



function TGanttChart.GetProjectTitleColour: TColor;
begin
   Result := FProjectTitleColour;
end;

procedure TGanttChart.SetProjectTitleColour(Value: TColor);
begin
   FProjectTitleColour := Value;
   Invalidate;
end;


function TGanttChart.GetShadowColour: TColor;
begin
   Result := FShadowColor;
end;

procedure TGanttChart.SetShadowColour(Value: TColor);
begin
   FShadowColor := Value;
   Invalidate;
end;

{ Override OnClick handler from TCustomControl }

procedure TGanttChart.Click;
begin
     { Code to execute before activating click
       behavior of component's parent class }

     { Activate click behavior of parent }
   inherited Click;

     { Code to execute after click behavior
       of parent }

end;

procedure TGanttChart.OnHintTimer(Sender: TObject);
begin
   FHintTimer.Enabled := False;
   FInHint := True;
   PaintHint;
end;


{ Override OnKeyPress handler from TCustomControl }

procedure TGanttChart.KeyPress(var Key: Char);
const
   TabKey = Char(VK_TAB);
   EnterKey = Char(VK_RETURN);
begin
     { Key contains the character produced by the keypress.
       It can be tested or assigned a new value before the
       call to the inherited KeyPress method.  Setting Key
       to #0 before call to the inherited KeyPress method
       terminates any further processing of the character. }

     { Activate KeyPress behavior of parent }
   inherited KeyPress(Key);

     { Code to execute after KeyPress behavior of parent }

end;

procedure TGanttChart.ClearCells;
     { Internal declarations for method }
     { type }
     { . . . }
     { var }
     { . . . }
begin

end;

constructor TGanttChart.Create(AOwner: TComponent);
begin
     { Call the Create method of the parent class }
   inherited Create(AOwner);
   ControlStyle := ControlStyle + [csOpaque];
     { AutoInitialize sets the initial values of variables and      }
     { properties; also, it creates objects for properties of       }
     { standard Delphi object types (e.g., TFont, TTimer,           }
     { TPicture) and for any variables marked as objects.           }
     { AutoInitialize method is generated by Component Create.      }
   AutoInitialize;

     { Code to perform other tasks when the component is created }

end;

destructor TGanttChart.Destroy;
begin
     { AutoDestroy, which is generated by Component Create, frees any   }
     { objects created by AutoInitialize.                               }
   AutoDestroy;

     { Here, free any other dynamic objects that the component methods  }
     { created but have not yet freed.  Also perform any other clean-up }
     { operations needed before the component is destroyed.             }

     { Last, free the component by calling the Destroy method of the    }
     { parent class.                                                    }
   inherited Destroy;
end;

function TGanttChart.GetEndDate: TDateTime;
     { Internal declarations for method }
     { type }
     { . . . }
     { var }
     { . . . }
begin

end;

function TGanttChart.GetStartDate: TDateTime;
     { Internal declarations for method }
     { type }
     { . . . }
     { var }
     { . . . }
begin

end;

procedure TGanttChart.Loaded;
begin
   inherited Loaded;

     { Perform any component setup that depends on the property
       values having been set }
end;


function GetPixelsPerPercent(Percent, Width: Integer): Integer;
begin
   Result := Trunc((Width / 100) * Percent);
end;


function ISWeekend(Year, Month, Day: Integer): Boolean;
var
   DayConst: Integer;
begin
   DayConst := DayOfTheWeek(EncodeDate(Year, Month, Day));
   case DayConst of
      6: Result := True;
      7: Result := True;
   else
      Result := False;
   end;
end;


{Function GetNumberOfDays(StartDate, EndDate : TDateTime) : Integer;
begin
  Result := DaysBetween(StartDate,EndDate);
end; }


function GetNumberOfDays(StartMonth, Months: Integer): Integer;
var
   StartDate, Enddate: TDateTime;
begin
   StartDate := EncodeDateTime(YearOf(Now), StartMonth, 1, 0, 0, 0, 0);
   Enddate := EncodeDateTime(YearOf(Now), StartMonth + Months, 1, 0, 0, 0, 0);
   Result := DaysBetween(StartDate, Enddate);
end;



function GetDaysInTheMonth(StartDate: TDateTime; Month: Integer): Integer;
var
   Year: Word;
begin
   Year := YearOf(StartDate);
   Result := DaysInAMonth(Year, Month);
end;


function TGanttchart.GetDayWidth(ClientWidth, Days: Integer): Integer;
begin
  // Result := trunc(ClientWidth / Days);
  Result := FDaysWidth;
end;


function SpanOfNowAndThen(const ANow, AThen: TDateTime): TDateTime;
begin 
  Result := Abs(ANow - AThen); 
end; 



function GetDaysFromStart(StartDate: Tdatetime; StartMonth: Integer): Integer;
var
   Start, Enddate: TDateTime;
begin
   Start := EncodeDateTime(YearOf(Now), StartMonth, 1, 0, 0, 0, 0); // start of chart
   Enddate := DateOf(StartDate);
   Result := DaysBetween(Start, Enddate);
end;



Function GetDaysLeft(StartDate : TDateTime; StartMonth, Days : Integer):Integer;
var
  Year, DayTaken :Word;
  Start, Enddate: TDateTime;
begin
  Start := EncodeDateTime(YearOf(Now), StartMonth, 1, 0, 0, 0, 0); // start of chart
  Enddate := incDay(StartDate,Days);  // end of project item
  if (Enddate < Start) then
     Result := -1
      else
       Result := DaysBetween(Start, Enddate);
end;



procedure TGanttChart.PaintHint;
var
   TempProj, TempItem : Integer;
   GanttItem : TGanttItem;
   TextHeight : Integer;
   TextStartX, TextStartY,HintX, HintY : Integer;
begin
   if XYtoGanttItem(CurrentX, CurrentY, TempProj, TempItem) = True then
   begin
      HintX := CurrentX + 10;
      HintY :=  CurrentY;
      Canvas.Pen.Color := clNavy;
      Canvas.brush.color := clInfoBK;
      Canvas.Rectangle(HintX, HintY, HintX + 200, HintY + 100);
      Canvas.Font.Name := 'Tahoma';
      Canvas.Font.Size := 9;

      TextStartX := HintX + 2;
      TextStartY := HintY + 5;
      TextHeight := Canvas.TextHeight('Hello There j');
      GanttItem := GetProjectItem(TempProj,TempItem);
      Canvas.TextOut(TextStartX, TextStartY, GanttItem.FItemName);

      inc(TextStartY,TextHeight);
      Canvas.TextOut(TextStartX, TextStartY, 'Status : '+StatusTypeToString(GanttItem.FItemStatus));

      inc(TextStartY,TextHeight);
      Canvas.TextOut(TextStartX, TextStartY, 'Starts : '+FormatDateTime('dd/mm/yyyy',GanttItem.FStartDate));

      inc(TextStartY,TextHeight);
      Canvas.TextOut(TextStartX, TextStartY, 'Length : '+IntToStr(GanttItem.FNumberOfDays)+' Days');

      inc(TextStartY,TextHeight);
      Canvas.Rectangle(TextStartX, TextStartY + 4, TextStartX + 100, TextStartY + 14);
      Canvas.TextOut(TextStartX + 110, TextStartY, IntToStr(GanttItem.FItemPercentage)+'%');
      Canvas.Brush.Color := clNavy;
      Canvas.Rectangle(TextStartX, TextStartY +6, TextStartX + GanttItem.FItemPercentage, TextStartY + 12);
  end;
end;




procedure TGanttChart.PaintHeader;
var
   PixPerMonth, SubPix: Integer;
   Index, Days, Day, DayPix, DaySub: Integer;
   FormatSettings : TformatSettings;
begin
   FOffScreenCanvas.Pen.Color := clNavy;
   FOffScreenCanvas.Rectangle(0, 0, Width, Height);
   FOffScreenCanvas.Rectangle(0, 0, width, 40);
   FOffScreenCanvas.Font.Name := 'Tahoma';
   FOffScreenCanvas.Font.Size := 12;


   FBoxWidth := 120;
   FBoxHeight := 40;
   FOffScreenCanvas.Rectangle(0, 0, FBoxWidth, FBoxHeight);
   FOffScreenCanvas.TextOut(10, 10, 'Project Tasks');

  //Canvas.TextOut(FBoxWidth +20,0, FGanttTitle); // fudge the screen

   PixPerMonth := Trunc((Width - FBoxWidth) / FMonthCount);
   FOffScreenCanvas.Font.Size := 6;
   FOffScreenCanvas.Font.Name := 'Tahoma';
   SubPix := FBoxWidth;
   for Index := 0 to FMonthCount do
   begin
      if (FStartMonth + Index) > 12 then exit;
      FOffScreenCanvas.MoveTo(SubPix, 0);
      FOffScreenCanvas.LineTo(SubPix, 20);
      FOffScreenCanvas.Font.Size := 10;
      FOffScreenCanvas.TextOut(SubPix + 30, 5, FormatSettings.LongMonthNames[FStartMonth + Index]);
      Days := GetDaysInTheMonth(Now, FStartMonth + Index);
      FOffScreenCanvas.Font.Size := 6;
      for Day := 1 to Days do
      begin
         DaySub := SubPix + (FDaysWidth * Day);

         if (Day mod 7 = 0) or (Day = 1) then
         begin
            FOffScreenCanvas.TextOut(DaySub - 3, 20, InttoStr(Day));
         end;

      if ISWeekend(2007, FStartMonth + Index, Day ) then
         begin
            FOffScreenCanvas.Pen.Color := clGray;
            FOffScreenCanvas.MoveTo(DaySub, 30);
            FOffScreenCanvas.LineTo(DaySub, Height);
         end
         else
         begin
            FOffScreenCanvas.Pen.Color := clSilver;
            FOffScreenCanvas.MoveTo(DaySub, 30);
            FOffScreenCanvas.LineTo(DaySub, Height);
         end;
      end;
      SubPix := DaySub;
   end;
end;






procedure TGanttChart.PaintItemLinks;
var
   ProjectIndex, ItemIndex: Integer;
   StartY, ChartStart, HalfHeight: Integer;
   Project, ProjectTo: TGanttProject;
   GanttItem, GanttoItem: TGanttItem;
   DrawtoRect : TRect;
   TempBrush: TBrush;
begin
   TempBrush := TBrush.Create;
   TempBrush.assign(FOffScreenCanvas.Brush);
   HalfHeight := Trunc(FProjectHeight / 2);
   for ProjectIndex := 0 to FGanttProjectList.count - 1 do
   begin
      Project := GetProject(ProjectIndex);
      for ItemIndex := 0 to Project.Count - 1 do
      begin
         GanttItem := Project.GetGanttItem(ItemIndex);
         if (Monthof(GanttItem.StartDate) < FStartMonth) then exit;
         if GanttItem.FItemLink.ProjectID > -1 then
         begin
             ProjectTo := GetProject(GanttItem.FItemLink.ProjectID);
             GanttoItem := ProjectTo.GetGanttItem(GanttItem.FItemLink.ItemID);
             if (Monthof(GanttoItem.StartDate) < FStartMonth) then exit;
             FOffScreenCanvas.Pen.Width := 2;
             FOffScreenCanvas.MoveTo(GanttItem.FItemPosition.X - 3,GanttItem.FItemPosition.Y + HalfHeight);

             FOffScreenCanvas.Ellipse(GanttItem.FItemPosition.X - 4,GanttItem.FItemPosition.Y + HalfHeight -4,
             GanttItem.FItemPosition.X + 4, GanttItem.FItemPosition.Y + HalfHeight + 4);

             if (GanttItem.FItemPosition.X < GanttoItem.FItemPosition.X) then
             begin
               FOffScreenCanvas.LineTo(GanttItem.FItemPosition.X - 30 ,GanttItem.FItemPosition.Y + HalfHeight);
               FOffScreenCanvas.LineTo(GanttItem.FItemPosition.X - 30 ,GanttoItem.FItemPosition.Y + HalfHeight);
             end
               else
             begin
               FOffScreenCanvas.LineTo(GanttoItem.FItemPosition.X - 30 ,GanttItem.FItemPosition.Y + HalfHeight);
               FOffScreenCanvas.LineTo(GanttoItem.FItemPosition.X - 30 ,GanttoItem.FItemPosition.Y + HalfHeight);
             end;
             FOffScreenCanvas.LineTo(GanttoItem.FItemPosition.X ,GanttoItem.FItemPosition.Y + HalfHeight);
             FOffScreenCanvas.Pen.Width := 1;
         end;
      end;
      FOffScreenCanvas.Brush.Assign(TempBrush);
   end;
   TempBrush.Free;
end;







procedure TGanttChart.PaintDiamondStyle(ItemRect: TRect; UseCanvas : TCanvas);
var
   HeadLength, ArrowHeight, HalfHeight, ArrowDip: Integer;
   StartX, Starty, Width: Integer;
begin
   HeadLength := FDaysWidth;
   StartX := ItemRect.Left;
   Starty := ItemRect.Top;
   HalfHeight := Trunc(FProjectHeight / 2);
   ArrowDip := Trunc(HeadLength * 1.7);
   ArrowHeight := ItemRect.Bottom;
   Width := ItemRect.Right;
   UseCanvas.Polygon([
   //arrowhead
      Point(StartX + HeadLength, ArrowHeight), //1      start
         Point(StartX, ArrowHeight - HalfHeight), //2      \
         Point(StartX + HeadLength, Starty), //3       /
         Point(StartX + ArrowDip , Starty + (HalfHeight-3)), //4       \
   //shaft
      Point(Width - ArrowDip, Starty + (HalfHeight-3)), //5       -
   //arrowhead
      Point(Width - HeadLength, Starty), //6       /
        Point(Width, ArrowHeight - HalfHeight), //7      \
        Point(Width - HeadLength, ArrowHeight), //8      /
        Point(Width - ArrowDip, ArrowHeight - (HalfHeight-3)), //9   \
      Point(StartX + ArrowDip, ArrowHeight - (HalfHeight-3)), //10 -
      Point(StartX + HeadLength, ArrowHeight)]);
end;



procedure TGanttChart.PaintPointStyle(ItemRect: TRect; UseCanvas : TCanvas);
var
   HeadLength, ArrowHeight, HalfHeight, ArrowDip: Integer;
   StartX, Starty, Width: Integer;
begin
   HeadLength := FDaysWidth div 2;
   StartX := ItemRect.Left;
   Starty := ItemRect.Top;
   HalfHeight := Trunc(FProjectHeight / 2);
   ArrowDip := Trunc(HeadLength * 1.7);
   ArrowHeight := ItemRect.Bottom;
   Width := ItemRect.Right;
   UseCanvas.Polygon([
   //arrowhead
      Point(StartX + HeadLength, ArrowHeight), //1      start
         Point(StartX, ArrowHeight - HalfHeight), //2      \
         Point(StartX, Starty), //3       |
   //shaft
      Point(Width, Starty), //5       -
   //arrowhead
        Point(Width, ArrowHeight - HalfHeight), //7      |
        Point(Width - HeadLength, ArrowHeight), //8      /
        Point(Width - ArrowDip, ArrowHeight - (HalfHeight)), //9   \
      Point(StartX + ArrowDip, ArrowHeight - (HalfHeight)), //10 -
      Point(StartX + HeadLength, ArrowHeight)]);
end;


procedure TGanttChart.PaintShardStyle(ItemRect: TRect; UseCanvas : TCanvas);
var
   HeadLength, ArrowHeight, HalfHeight, ArrowDip: Integer;
   StartX, Starty, Width: Integer;
begin
   HeadLength := FDaysWidth div 2;
   StartX := ItemRect.Left;
   Starty := ItemRect.Top;
   HalfHeight := 6;
   ArrowDip := Trunc(HeadLength * 1.7);
   ArrowHeight := ItemRect.Bottom;
   Width := ItemRect.Right;
   UseCanvas.Polygon([
   //arrowhead
      Point(StartX, ArrowHeight), //1      start
         Point(StartX, Starty), //3       |
   //shaft
      Point(Width, Starty), //5       -
   //arrowhead
        Point(Width, ArrowHeight), //7      |
        Point(Width - ArrowDip, Starty + HalfHeight), //9   \
      Point(StartX + ArrowDip, Starty + HalfHeight), //10 -
      Point(StartX, ArrowHeight)]);
end;



procedure TGanttChart.paintArrowStyle(ItemRect: TRect; UseCanvas : TCanvas);
var
   HeadLength, ArrowHeight, HalfHeight, ArrowDip: Integer;
   StartX, Starty, Width: Integer;
begin
   HeadLength := 16;
   StartX := ItemRect.Left;
   Starty := ItemRect.Top;
   HalfHeight := Trunc(FProjectHeight / 2);
   ArrowDip := Trunc(FProjectHeight / 5);
   ArrowHeight := ItemRect.Bottom;
   Width := ItemRect.Right;
   UseCanvas.Polygon([
   //arrowhead
      Point(StartX + HeadLength, ArrowHeight), //1      start
         Point(StartX, ArrowHeight - HalfHeight), //2      \
         Point(StartX + HeadLength, Starty), //3       /
         Point(StartX + HeadLength, Starty + ArrowDip), //4       |
   //shaft
      Point(Width - HeadLength, Starty + ArrowDip), //5       -
         Point(Width - HeadLength, Starty), //6       |
   //arrowhead
      Point(Width, ArrowHeight - HalfHeight), //7      \
         Point(Width - HeadLength, ArrowHeight), //8      /

      Point(Width - HeadLength, ArrowHeight - ArrowDip), //9     _
         Point(StartX + HeadLength, ArrowHeight - ArrowDip)]); //10
end;





Function TGanttChart.CalculateShadowoffsett(StartRect : TRect): TRect;
var
  ShadowRect : Trect;
begin
  ShadowRect := StartRect;
  inc(ShadowRect.Top,FShadowSize);
  inc(ShadowRect.Left,FShadowSize);
  inc(ShadowRect.Right,FShadowSize);
  inc(ShadowRect.Bottom,FShadowSize);
  Result := ShadowRect;
end;





procedure TGanttChart.PaintOneMovingGanttItem(StartY: Integer; GanttItem: TGanttItem);
var
   ChartStart: Integer;
   HalfDay, HalfHeight, TextHeight: Integer;
   TempFont: Tfont;
   GanttDaystoPaint : Integer;
   PrintText : Boolean;

begin
   TempFont := Tfont.Create;
   try
      FOffScreenCanvas.Brush.Assign(GanttItem.ItemBrush);
      TempFont.Assign(FOffScreenCanvas.Font);
      FOffScreenCanvas.Font.Assign(GanttItem.FItemFont);
      HalfDay := Trunc(FDaysWidth / 2);
      HalfHeight := Trunc(FProjectHeight / 2);
      GanttDaystoPaint := GanttItem.Days;
       if (Monthof(GanttItem.StartDate) < FStartMonth) then
       begin
           ChartStart := FBoxWidth;
           GanttDaystoPaint := GetDaysLeft(GanttItem.FStartDate, FStartMonth, GanttItem.Days);
           if GanttDaystoPaint < 1 then exit;
       end
           else
      ChartStart := (GetDaysFromStart(GanttItem.StartDate, FStartMonth) * FDaysWidth) + FBoxWidth;
      PrintText := True;

      if (FDragging = True) then
      begin
         GanttItem.FItemDrawRect.Left := ChartStart + DeltaX;
         GanttItem.FItemDrawRect.Top := (StartY - FProjectHeight) + Deltay;
         GanttItem.FItemDrawRect.Right := ((FDaysWidth * GanttDaystoPaint) + ChartStart)+ DeltaX;
         GanttItem.FItemDrawRect.Bottom := Starty + Deltay;
      end
      else
       begin
         GanttItem.FItemDrawRect.Left := ChartStart;
         GanttItem.FItemDrawRect.Top := (StartY - FProjectHeight);
         GanttItem.FItemDrawRect.Right := ((FDaysWidth * GanttDaystoPaint) + ChartStart)+ DeltaX;
         GanttItem.FItemDrawRect.Bottom := Starty;
       end;


      GanttItem.FItemPosition.X := GanttItem.FItemDrawRect.Left;
      GanttItem.FItemPosition.Y := GanttItem.FItemDrawRect.Top;

      if GanttItem.FitemType = dsBlock then
         FOffScreenCanvas.Rectangle(GanttItem.FItemDrawRect);

      if GanttItem.FitemType = dsBall then
         FOffScreenCanvas.RoundRect(GanttItem.FItemDrawRect.Left, GanttItem.FItemDrawRect.Top, GanttItem.FItemDrawRect.Right, GanttItem.FItemDrawRect.Bottom, FProjectHeight, FProjectHeight);

      if GanttItem.FitemType = dsRing then
         FOffScreenCanvas.Ellipse(GanttItem.FItemDrawRect);

      if GanttItem.FitemType = dsArrow then
         paintArrowStyle(GanttItem.FItemDrawRect, FOffScreenCanvas);

      if GanttItem.FitemType = dsFinish then
      begin
         FOffScreenCanvas.Polygon([Point(GanttItem.FItemDrawRect.Left, GanttItem.FItemDrawRect.Bottom + 1),
          Point(GanttItem.FItemDrawRect.Left, GanttItem.FItemDrawRect.Bottom - FProjectHeight),
           Point(GanttItem.FItemDrawRect.Left + FDaysWidth, GanttItem.FItemDrawRect.Bottom - HalfHeight),
            Point(GanttItem.FItemDrawRect.Left, GanttItem.FItemDrawRect.Bottom + 1)]);
      end;

      if GanttItem.FitemType = dsBenchMark then
      begin
         FOffScreenCanvas.Polygon([Point(GanttItem.FItemDrawRect.Left, GanttItem.FItemDrawRect.Bottom  - 1),
          Point(GanttItem.FItemDrawRect.Left, GanttItem.FItemDrawRect.Bottom  - HalfHeight),
           Point(GanttItem.FItemDrawRect.Left + HalfDay, GanttItem.FItemDrawRect.Bottom  - FProjectHeight),
            Point(GanttItem.FItemDrawRect.Left + FDaysWidth, GanttItem.FItemDrawRect.Bottom  - HalfHeight),
             Point(GanttItem.FItemDrawRect.Left + FDaysWidth, GanttItem.FItemDrawRect.Bottom  - 1),
              Point(GanttItem.FItemDrawRect.Left, GanttItem.FItemDrawRect.Bottom  - 1)]);
        FOffScreenCanvas.MoveTo( GanttItem.FItemDrawRect.Left + HalfDay, GanttItem.FItemDrawRect.Bottom  - FProjectHeight );
        FOffScreenCanvas.LineTo(GanttItem.FItemDrawRect.Left + HalfDay, 40 );
        PrintText := False;
      end;

      if GanttItem.FitemType = dsEnd then
      begin
        FOffScreenCanvas.Rectangle(GanttItem.FItemDrawRect.Left,40,GanttItem.FItemDrawRect.Left + FDaysWidth,GanttItem.FItemDrawRect.Bottom);
        PrintText := False;
      end;

      if GanttItem.FitemType = dsDiaGroup then
         paintDiamondStyle(GanttItem.FItemDrawRect,FOffScreenCanvas);

      if GanttItem.FitemType = dsPointGroup then
         PaintPointStyle(GanttItem.FItemDrawRect,FOffScreenCanvas);

      if GanttItem.FitemType = dsShardGroup then
         PaintShardStyle(GanttItem.FItemDrawRect,FOffScreenCanvas);



      FOffScreenCanvas.Brush.Style := bsClear;
      TextHeight := FOffScreenCanvas.TextHeight(GanttItem.ItemName);
      if (FShowItemLength = True) and (PrintText <> False) then
        FOffScreenCanvas.TextOut(GanttItem.FItemDrawRect.Left + 11, (GanttItem.FItemDrawRect.Bottom - (HalfHeight + 5)), GanttItem.ItemName + ' : ' + inttostr(GanttItem.FNumberOfDays) + ' Days')
         else
          FOffScreenCanvas.TextOut(GanttItem.FItemDrawRect.Left + 11, (GanttItem.FItemDrawRect.Bottom - (HalfHeight + 5)), GanttItem.ItemName);
      FOffScreenCanvas.Font.Assign(TempFont);
   finally
      TempFont.free;
   end;
end;






procedure TGanttChart.PaintOneGanttItem(StartY: Integer; GanttItem: TGanttItem);
var
   ChartStart: Integer;
   HalfDay, HalfHeight, TextHeight: Integer;
   TempFont: Tfont;
   GanttDaystoPaint : Integer;
   ShadowRect,ShadowBitmapRect : TRect;
   ShadowBitmap : TBitmap;
   PrintText : Boolean;

begin
   TempFont := Tfont.Create;
   try
      FOffScreenCanvas.Brush.Assign(GanttItem.ItemBrush);
      TempFont.Assign(FOffScreenCanvas.Font);
      FOffScreenCanvas.Font.Assign(GanttItem.FItemFont);
      HalfDay := Trunc(FDaysWidth / 2);
      HalfHeight := Trunc(FProjectHeight / 2);
      GanttDaystoPaint := GanttItem.Days;
       if (Monthof(GanttItem.StartDate) < FStartMonth) then
       begin
           ChartStart := FBoxWidth;
           GanttDaystoPaint := GetDaysLeft(GanttItem.FStartDate, FStartMonth, GanttItem.Days);
           if GanttDaystoPaint < 1 then exit;
       end
           else
      ChartStart := (GetDaysFromStart(GanttItem.StartDate, FStartMonth) * FDaysWidth) + FBoxWidth;
      PrintText := True;
      GanttItem.FItemDrawRect.Left := ChartStart;
      GanttItem.FItemDrawRect.Top := StartY - FProjectHeight;
      GanttItem.FItemDrawRect.Right := (FDaysWidth * GanttDaystoPaint) + ChartStart;
      GanttItem.FItemDrawRect.Bottom := Starty;
      GanttItem.FItemPosition.X := GanttItem.FItemDrawRect.Left;
      GanttItem.FItemPosition.Y := GanttItem.FItemDrawRect.Top;

      if FShadows = True then // create dynamic soft shadows
      begin
      ShadowRect := CalculateShadowoffsett(GanttItem.FItemDrawRect);
      ShadowBitmap := TBitmap.create;
      ShadowBitmap.PixelFormat:= pf24Bit;
      ShadowBitmap.Width := (ShadowRect.Right - ShadowRect.Left) +2;
      ShadowBitmap.Height := (ShadowRect.Bottom - ShadowRect.Top) + 2;
      ShadowBitmap.Canvas.Brush.Color := clWhite;
      ShadowBitmap.Canvas.Brush.Style := bsSolid;
      ShadowBitmap.Canvas.Pen.Color := clWhite;
      ShadowBitmapRect := Rect(0,0,ShadowBitmap.Width -2,ShadowBitmap.Height-2);
      ShadowBitmap.Canvas.Rectangle(ShadowBitmapRect);
      
      ShadowBitmap.Canvas.Brush.Color := FShadowColor;
      ShadowBitmap.Canvas.Pen.Color := FShadowColor;

      if GanttItem.FitemType = dsBlock then
         ShadowBitmap.Canvas.Rectangle(ShadowBitmapRect);

      if GanttItem.FitemType = dsBall then
         ShadowBitmap.Canvas.RoundRect(ShadowBitmapRect.Left, ShadowBitmapRect.Top, ShadowBitmapRect.Right, ShadowBitmapRect.Bottom, FProjectHeight, FProjectHeight);

      if GanttItem.FitemType = dsRing then
         ShadowBitmap.Canvas.Ellipse(ShadowBitmapRect);

      if GanttItem.FitemType = dsArrow then
         paintArrowStyle(ShadowBitmapRect,ShadowBitmap.Canvas);

      if GanttItem.FitemType = dsFinish then
      begin
         ShadowBitmap.Canvas.Polygon([Point(ShadowBitmapRect.Left, ShadowBitmapRect.Bottom + 1),
          Point(ShadowBitmapRect.Left, ShadowBitmapRect.Bottom - FProjectHeight),
           Point(ShadowBitmapRect.Left + FDaysWidth, ShadowBitmapRect.Bottom - HalfHeight),
            Point(ShadowBitmapRect.Left, ShadowBitmapRect.Bottom + 1)]);
      end;
      if GanttItem.FitemType = dsBenchMark then
      begin
         ShadowBitmap.Canvas.Polygon([Point(ShadowBitmapRect.Left, ShadowBitmapRect.Bottom - 1),
          Point(ShadowBitmapRect.Left, ShadowBitmapRect.Bottom - HalfHeight),
           Point(ShadowBitmapRect.Left + HalfDay, ShadowBitmapRect.Bottom - FProjectHeight),
            Point(ShadowBitmapRect.Left + FDaysWidth, ShadowBitmapRect.Bottom - HalfHeight),
             Point(ShadowBitmapRect.Left + FDaysWidth, ShadowBitmapRect.Bottom - 1),
              Point(ShadowBitmapRect.Left, ShadowBitmapRect.Bottom - 1)]);
      end;

      if GanttItem.FitemType = dsDiaGroup then
         paintDiamondStyle(ShadowBitmapRect,ShadowBitmap.Canvas);

      if GanttItem.FitemType = dsPointGroup then
         PaintPointStyle(ShadowBitmapRect,ShadowBitmap.Canvas);

      if GanttItem.FitemType = dsShardGroup then
         PaintShardStyle(ShadowBitmapRect,ShadowBitmap.Canvas);


      GBlur(ShadowBitmap,1.5);
      BitBlt(FOffScreenCanvas.Handle,ShadowRect.Left, ShadowRect.Top,
        ShadowRect.Right +3, ShadowRect.Bottom +3, ShadowBitmap.Canvas.Handle, 0, 0, SRCAND );
      ShadowBitmap.Free;
      end; // shadows


      if GanttItem.FitemType = dsBlock then
         FOffScreenCanvas.Rectangle(GanttItem.FItemDrawRect);

      if GanttItem.FitemType = dsBall then
         FOffScreenCanvas.RoundRect(GanttItem.FItemDrawRect.Left, GanttItem.FItemDrawRect.Top, GanttItem.FItemDrawRect.Right, GanttItem.FItemDrawRect.Bottom, FProjectHeight, FProjectHeight);

      if GanttItem.FitemType = dsRing then
         FOffScreenCanvas.Ellipse(GanttItem.FItemDrawRect);

      if GanttItem.FitemType = dsArrow then
         paintArrowStyle(GanttItem.FItemDrawRect,FOffScreenCanvas);

      if GanttItem.FitemType = dsFinish then
      begin
         FOffScreenCanvas.Polygon([Point(ChartStart, Starty + 1),
          Point(ChartStart, Starty - FProjectHeight),
           Point(ChartStart + FDaysWidth, Starty - HalfHeight),
            Point(ChartStart, Starty + 1)]);
      end;

      if GanttItem.FitemType = dsBenchMark then
      begin
         FOffScreenCanvas.Polygon([Point(ChartStart, Starty - 1),
          Point(ChartStart, Starty - HalfHeight),
           Point(ChartStart + HalfDay, Starty - FProjectHeight),
            Point(ChartStart + FDaysWidth, Starty - HalfHeight),
             Point(ChartStart + FDaysWidth, Starty - 1),
              Point(ChartStart, Starty - 1)]);
        FOffScreenCanvas.MoveTo( GanttItem.FItemDrawRect.Left + HalfDay, GanttItem.FItemDrawRect.Bottom  - FProjectHeight );
        FOffScreenCanvas.LineTo(GanttItem.FItemDrawRect.Left + HalfDay, 40 );
        PrintText := False;
      end;

      if GanttItem.FitemType = dsEnd then
      begin
        FOffScreenCanvas.Rectangle(GanttItem.FItemDrawRect.Left,40,GanttItem.FItemDrawRect.Left + FDaysWidth,GanttItem.FItemDrawRect.Bottom);
        PrintText := False;
      end;

      if GanttItem.FitemType = dsDiaGroup then
         paintDiamondStyle(GanttItem.FItemDrawRect,FOffScreenCanvas);

      if GanttItem.FitemType = dsPointGroup then
         PaintPointStyle(GanttItem.FItemDrawRect,FOffScreenCanvas);

      if GanttItem.FitemType = dsShardGroup then
         PaintShardStyle(GanttItem.FItemDrawRect,FOffScreenCanvas);


     FOffScreenCanvas.Brush.Style := bsClear;
      TextHeight := FOffScreenCanvas.TextHeight(GanttItem.ItemName);
      if (FShowItemLength = True) and (PrintText <> False) then
        FOffScreenCanvas.TextOut(ChartStart + 11, (StartY - (HalfHeight + 5)), GanttItem.ItemName + ' : ' + inttostr(GanttItem.FNumberOfDays) + ' Days')
         else
          FOffScreenCanvas.TextOut(ChartStart + 11, (StartY - (HalfHeight + 5)), GanttItem.ItemName);
     FOffScreenCanvas.Font.Assign(TempFont);
   finally
      TempFont.free;
   end;
end;




procedure TGanttChart.PaintOneProject(StartY: Integer; Project: TGanttProject);
begin
   FOffScreenCanvas.Brush.Color := FProjectTitleColour;
   FOffScreenCanvas.Brush.Style := bsSolid;
   FOffScreenCanvas.Rectangle(0, StartY - FProjectHeight, FBoxWidth, StartY);
   FOffScreenCanvas.MoveTo(0, StartY);
   FOffScreenCanvas.LineTo(width, StartY);
   Project.FItemDrawRect.Left := 0;
   Project.FItemDrawRect.Top := StartY - FProjectHeight;
   Project.FItemDrawRect.Right := Width;
   Project.FItemDrawRect.Bottom := StartY;
   FOffScreenCanvas.TextOut(4, StartY - 14, Project.FProjectName);
end;



procedure TGanttChart.PaintProjects;
var
   ProjectIndex, ItemIndex: Integer;
   StartY, ChartStart: Integer;
   Project: TGanttProject;
   GanttItem: TGanttItem;
   TempBrush: TBrush;
begin
   FDaysOnScreen := GetNumberOfDays(FStartMonth, FMonthCount);
   //FDaysWidth := GetDayWidth(Width - FBoxWidth, FDaysOnScreen);

   StartY := FBoxHeight + FProjectHeight;
   FOffScreenCanvas.Pen.Color := clBlack;
   FOffScreenCanvas.Font.Name := 'Tahoma';
   FOffScreenCanvas.Font.Size := 7;
   TempBrush := TBrush.Create;
   TempBrush.assign(FOffScreenCanvas.Brush);
   for ProjectIndex := 0 to FGanttProjectList.count - 1 do
   begin
      Project := GetProject(ProjectIndex);
      PaintOneProject(StartY, Project); // Paint the project lines
      if ProjectIndex = ProjectDragIndex then
          begin
            FOffScreenCanvas.Pen.Color := clBlue;
            FOffScreenCanvas.Brush.Style := bsClear;
            FOffScreenCanvas.Rectangle(Project.FItemDrawRect);
            FOffScreenCanvas.Pen.Color := clBlack;
          end;
      for ItemIndex := 0 to Project.Count - 1 do
      begin
         GanttItem := Project.GetGanttItem(ItemIndex);
         if (ItemIndex = ItemDragIndex) and (ProjectIndex = ProjectDragIndex) then
           PaintOneMovingGanttItem(StartY, GanttItem) // paint the gantt items if moving or dragging
           else
             PaintOneGanttItem(StartY, GanttItem); // paint the gantt items
      end;
      FOffScreenCanvas.Brush.Assign(TempBrush);
      inc(StartY, FProjectHeight); // project lines
   end;
   TempBrush.Free;
end;




procedure TGanttChart.Paint;
begin
   FMemBitmap.Width := ClientWidth;
   FMemBitmap.Height := ClientHeight;
   PaintHeader;
   PaintProjects;
   PaintItemLinks;
   Canvas.Draw(Canvas.ClipRect.Left, Canvas.ClipRect.Top, FMemBitmap);
end;


Procedure TGanttChart.SaveChartToBitmap(FileName : String);
begin
  Invalidate;
  FMemBitmap.SaveToFile(FileName);
end;



Procedure TGanttChart.PrintChart;
var
  TempCap: array[0..255] of char;
  pHeight, pWidth: Integer;
  DrawFlags: Longint;
  TheRect: TRect;
  Ratio: Extended;
begin
  { Work out the page size and margins }
  with fPrintOptions do
  begin
    Printer.Orientation := fPrinterOrientation;
    { The page width and height exclude the margins }
    pWidth := Printer.PageWidth - fPrinterLeftMargin - fPrinterRightMargin;
    pHeight := Printer.PageHeight - fPrinterTopMargin - fPrinterBottomMargin;
    { Resize the page size based on the reduction ratio }
    PrinterPageWidth := round(pWidth * (fPrintReductionSize / 100));
    PrinterPageHeight := round(pHeight * (fPrintReductionSize / 100));
    {Preserve Aspect Ratio}
    if PreserveAspect then
    begin
      Ratio := Height/Width;
      PrinterPageHeight := round(Ratio * PrinterPageWidth);
      if PrinterPageHeight > pHeight then
      begin
        PrinterPageWidth:= round(PrinterPageWidth*(pHeight/PrinterPageHeight));
        PrinterPageHeight:= round(pHeight);
      end;
    end;
    { Set the margins }
    PrinterLeftMargin := fPrinterLeftMargin;
    PrinterTopMargin := fPrinterTopMargin;
    PrinterRightMargin := fPrinterRightMargin;
    PrinterBottomMargin := fPrinterBottomMargin;
  end;
  try
    Printer.BeginDoc;
    { Paint the Chart }
    self.Paint;
    StretchBlt(Printer.Canvas.Handle, PrinterLeftMargin, PrinterTopMargin,
      PrinterPageWidth, PrinterPageHeight, Canvas.Handle, 0, 0,
      Width, Height, SRCCOPY);
    { Draw the headers and footers }
    with fPrintOptions, Printer.Canvas do
    begin
      { Draw the header }
      if PrintHeader.Caption <> '' then
      begin
        { Setup the header }
        StrPCopy(TempCap, PrintHeader.Caption);
        Font := PrintHeader.Font;
        TheRect := Rect(PrinterLeftMargin, 0, PrinterLeftMargin + pWidth,
          PrinterTopMargin);
        { The text is vetically centered in the top margin }
        DrawFlags := DT_VCENTER or DT_SINGLELINE;
        { Do the alignment }
        case PrintHeader.Alignment of
          taLeftJustify: DrawFlags := DrawFlags or DT_LEFT;
          taCenter: DrawFlags := DrawFlags or DT_CENTER;
          taRightJustify: DrawFlags := DrawFlags or DT_RIGHT;
        end;
        { Draw the text }
        DrawText(Handle, TempCap, StrLen(TempCap), TheRect, DrawFlags);
      end;
      { Draw the footer }
      if PrintFooter.Caption <> '' then
      begin
        { Setup the footer }
        StrPCopy(TempCap, PrintFooter.Caption);
        Font := PrintFooter.Font;
        TheRect := Rect(PrinterLeftMargin, PrinterTopMargin + pHeight,
          PrinterLeftMargin + pWidth, PrinterTopMargin + pHeight + PrinterBottomMargin);
        { The text is vetically centered in the bottom margin }
        DrawFlags := DT_VCENTER or DT_SINGLELINE;
        { Do the alignment }
        case PrintFooter.Alignment of
          taLeftJustify: DrawFlags := DrawFlags or DT_LEFT;
          taCenter: DrawFlags := DrawFlags or DT_CENTER;
          taRightJustify: DrawFlags := DrawFlags or DT_RIGHT;
        end;
        { Draw the text }
        DrawText(Handle, TempCap, StrLen(TempCap), TheRect, DrawFlags);
      end;
    end;
  finally
    Printer.EndDoc;
  end;
end;


function InRect(x, y: Integer; MyRect: TRect): boolean;
begin
   if (x > MyRect.Left) and (x < MyRect.right) and (y > MyRect.top) and (y < MyRect.Bottom) then
      InRect := true
   else
      InRect := false;
end;



function TGanttChart.XYtoGanttItem(X, Y: Integer; var ProjectID, ItemID: Integer): Boolean;
var
   ProjectIndex, ItemIndex: Integer;
   Project: TGanttProject;
   GanttItem: TGanttItem;
begin
   Result := False;
   for ProjectIndex := 0 to FGanttProjectList.count - 1 do
   begin
      Project := GetProject(ProjectIndex);
      for ItemIndex := 0 to Project.Count - 1 do
      begin
         GanttItem := Project.GetGanttItem(ItemIndex);
         if InRect(X, Y, GanttItem.FItemDrawRect) then
         begin
            ProjectID := ProjectIndex;
            ItemID := ItemIndex;
            DragGanttItemRect := GanttItem.FItemDrawRect;
            Result := True;
            exit;
         end;
      end;
   end;
end;



function TGanttChart.XYtoGanttProject(X, Y: Integer; var ProjectID: Integer): Boolean;
var
   ProjectIndex: Integer;
   Project: TGanttProject;
begin
   Result := False;
   for ProjectIndex := 0 to FGanttProjectList.count - 1 do
   begin
      Project := GetProject(ProjectIndex);
      if InRect(X, Y, Project.FItemDrawRect) then
      begin
         ProjectID := ProjectIndex;
         Result := True;
         exit;
      end;
   end;
end;



function TGanttChart.XYtoGanttProjectTitle(X, Y: Integer; var ProjectID: Integer): Boolean;
var
   ProjectIndex: Integer;
   Project: TGanttProject;
   TestRect : TRect;
begin
   Result := False;
   for ProjectIndex := 0 to FGanttProjectList.count - 1 do
   begin
      Project := GetProject(ProjectIndex);
      TestRect := Project.FItemDrawRect;
      TestRect.Right := FBoxWidth;
      if InRect(X, Y, TestRect) then
      begin
         ProjectID := ProjectIndex;
         Result := True;
         exit;
      end;
   end;
end;



end.
